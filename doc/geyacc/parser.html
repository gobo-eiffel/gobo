<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<title>Geyacc: The Generated Parser</title>
</head>

<body bgcolor="#FFFFFF">

<h1>The Generated Parser</h1>

<hr size="1">

<p>For each parser description file given as input, <em>geyacc</em>
will generate an Eiffel class as output. The deferred class <a
href="skeleton.html"><font color="#008080" size="2"
face="Courier New"><em>YY_PARSER</em></font></a>, which is part
of <em>Gobo Eiffel Parse Library</em>, provides an abstraction
for parsers. Every parser class generated by <em>geyacc</em> will
be a descendant of this class. The main feature of <font
color="#008080" size="2" face="Courier New"><em>YY_PARSER</em></font>
is routine <a href="skeleton.html#parse" name="parse"><font
color="#008080" size="2" face="Courier New"><em>parse</em></font></a><font
color="#008080" size="2" face="Courier New"><em> </em></font>which,
when called, reads tokens, executes actions and ultimately
returns when it encounters the end of input or an unrecoverable
syntax error. <font color="#008080" size="2" face="Courier New"><em>parse
</em></font>sets <a href="skeleton.html#syntax_error"
name="syntax_error"><font color="#008080" size="2"
face="Courier New"><em>syntax_error</em></font></a><font
color="#008080" size="2" face="Courier New"><em> </em></font>to
false if the parsing was successful. Otherwise, if an
unrecoverable error is detected, <font color="#008080" size="2"
face="Courier New"><em>syntax_error</em></font> is set to true
and the error is reported by calling <a
href="actions.html#report_error"><font color="#008080" size="2"
face="Courier New"><em>report_error</em></font></a>. By default
this routine just prints a message on the screen, but it can
easily be redefined to suit your needs. Also of interest is
feature <a href="actions.html#error_count"><font color="#008080"
size="2" face="Courier New"><em>error_count</em></font></a> which
keeps track of the number of syntax errors (recovered and fatal)
detected during the last parsing.</p>

<p>The <a name="lexical_analyzer"><em>lexical analyzer</em></a>
routine, <a href="actions.html#read_token"><font color="#008080"
size="2" face="Courier New"><em>read_token</em></font></a>,
recognizes tokens from the input stream and makes them available
to the parser in <a href="actions.html#last_token"><font
color="#008080" size="2" face="Courier New"><em>last_token</em></font></a>.
<em>Geyacc</em> does not provide a default implementation for <font
color="#008080" size="2" face="Courier New"><em>read_token</em></font>
and <font color="#008080" size="2" face="Courier New"><em>last_token</em></font>,
so you must define these two deferred features. In simple
programs, <font color="#008080" size="2" face="Courier New"><em>read_token
</em></font>is often defined at the end of the <em>geyacc</em>
grammar file, in the <a href="description.html#user_code">user
code section</a>. If <font color="#008080" size="2"
face="Courier New"><em>read_token </em></font>is defined in a
separate class, you need to arrange for the token-type integer
constant definitions to be available there. To do this, use the <font
color="#800000" size="2" face="Courier New">-d</font> option when
you run <em>geyacc</em>, so that it will write these integer
constant definitions into a separate class. </p>

<p>The value that <font color="#008080" size="2"
face="Courier New"><em>read_token </em></font>returns in <font
color="#008080" size="2" face="Courier New"><em>last_token </em></font>must
be the numeric code for the <a href="symbols.html">type of token</a>
it has just found, or 0 for end-of-input. When a token is
referred to in the grammar rules by a name, that name in the
parser file becomes an integer constant whose value is the proper
numeric code for that token type. So <font color="#008080"
size="2" face="Courier New"><em>read_token </em></font>can use
the name to indicate that type. When a token is referred to in
the grammar rules by a character literal, the numeric code for
that character is also the code for the token type. So <font
color="#008080" size="2" face="Courier New"><em>read_token </em></font>can
simply return that character code. The null character must not be
used this way, because its code is zero and that is what
signifies end-of-input. Here is an example showing these things:</p>

<blockquote>
    <pre><font color="#008080"><em>read_token</em> <em><strong>is</strong></em>
        -- Read a token from input stream.
        -- Make result available in <em>last_token</em>.
    <em><strong>local</strong></em>
        <em>c</em>: <em>CHARACTER</em>
    <em><strong>do</strong></em>
        ...
        <em><strong>if</strong></em> <em>c</em> = <em>EOF</em> <em><strong>then</strong></em>
                -- Detect end of file.
            <em>last_token</em> := <em>0</em>
        <em><strong>elseif</strong></em> <em>c</em> = <em>'+' </em><em><strong>or</strong></em><em> c</em> = <em>'-' </em><em><strong>then</strong></em>
                -- Assume token type for `+' is '+'.
            <em>last_token</em> := <em>c.code</em>
        <em><strong>elseif</strong></em> ... <em><strong>then</strong></em>
                 -- Return the type of the token.
             <em>last_token</em> := <em>INT</em>
        <em><strong>else</strong></em>
            ...
        <em><strong>end</strong></em>
    <em><strong>end</strong></em></font></pre>
</blockquote>

<p>This interface has been designed so that the output from the <a
href="../gelex/gelex.html"><em>gelex</em></a> utility can be used
without change as the definition of <font color="#008080"
size="2" face="Courier New"><em>read_token</em></font>.</p>

<p><font color="#008080" size="2" face="Courier New"><em>YY_PARSER</em></font>
is actually a generic class whose generic parameter specifies the
type of the <a href="introduction.html#semantic_values">semantic
values</a> associated with each token. When scanning the input
stream for a new token, <font color="#008080" size="2"
face="Courier New"><em>read_token</em></font> must update the
semantic value of the token being read in feature <a
href="actions.html#last_value"><font color="#008080" size="2"
face="Courier New"><em>last_value</em></font></a>. As for <font
color="#008080" size="2" face="Courier New"><em>read_token</em></font>
and <font color="#008080" size="2" face="Courier New"><em>last_token</em></font>,
<font color="#008080" size="2" face="Courier New"><em>last_value</em></font>
is a deferred feature for which you must provide an
implementation.</p>

<p>Class <font color="#008080" size="2" face="Courier New"><em>YY_PARSER</em></font>
is equipped with a procedure <a href="skeleton.html#make"
name="make"><font color="#008080" size="2" face="Courier New"><em>make</em></font></a>
which initializes the parser. This routine should be used as
creation routine in descendant classes. Also available to
descendants of <font color="#008080" size="2" face="Courier New"><em>YY_PARSER
</em></font>are a set of features which can be called from the
semantic <a href="actions.html">actions</a>. An implementation
for most of these routines is provided in class <font
color="#008080" size="2" face="Courier New"><em>YY_PARSER_SKELETON</em></font>.</p>

<p><em>Geyacc</em> does not automatically generate the indexing,
class header, formal generics, obsolete, inheritance, creation
and invariant clauses. These have to be specified in <a
href="description.html#eiffel_declarations">Eiffel declarations</a>
in the first section and in the <a
href="description.html#user_code">user code section</a> of the
parser <a href="description.html">description file</a>. The
following example shows a typical parser description file:</p>

<blockquote>
    <pre><font color="#0000FF" size="3">%{</font><font size="3">
</font><font color="#008080" size="3"><em><strong>class</strong></em><em> MY_PARSER

</em><em><strong>inherit</strong></em><em>

    YY_PARSER_SKELETON </em>[<em>INTEGER</em>]<em>
        </em><em><strong>rename</strong></em><em>
            make as make_parser_skeleton
        </em><em><strong>redefine</strong></em><em>
            report_error
        </em><em><strong>end</strong></em><em>

    MY_SCANNER
        </em><em><strong>rename</strong></em><em>
            make as make_scanner
        </em><em><strong>export</strong></em><em>
            </em>{<em>NONE</em>}<em> </em><em><strong>all</strong></em><em>
        </em><em><strong>end</strong></em><em>

</em><em><strong>creation</strong></em><em>

    make</em></font><font size="3"><em>
</em></font><font color="#0000FF" size="3">%}</font></pre>
    <pre><font color="#0000FF" size="3">%token</font><font
size="3"> ...

</font><font color="#0000FF" size="3">%%</font><font size="3">

</font><font color="#FF0000" size="3">...rules...</font><font
size="3">

</font><font color="#0000FF" size="3">%%</font><font size="3">

</font><font color="#008080" size="3"><em><strong>feature</strong></em><em> </em>{<em>NONE</em>} -- Initialization<em>

    make </em><em><strong>is</strong></em><em>
            </em>-- Create a new parser.<em>
        </em><em><strong>do</strong></em><em>
            make_scanner
            make_parser_skeleton
            </em>!!<em> error_messages.make
        </em><em><strong>end</strong></em><em>

</em><em><strong>feature</strong></em><em> </em>-- Access<em>

    error_messages: LINKED_LIST </em>[<em>STRING</em>]<em>
            </em>-- Error messages reported so far<em>
</em><em><strong>
feature</strong></em><em> </em>{<em>NONE</em>} -- Error<em> </em>reporting<em>

    report_error </em>(<em>a_message</em>:<em> STRING</em>)<em> </em><em><strong>is</strong></em><em>
            -- S</em>tore error message in<em> error_messages.
        </em><em><strong>do</strong></em><em>
            error_messages.extend </em>(<em>a_message</em>)<em>
        </em><em><strong>end</strong></em><em>

</em><em><strong>invariant</strong></em><em>

    error_messages_not_void</em>:<em> error_messages </em>/=<em> Void

</em><em><strong>end</strong></em><em> </em>-- class MY_PARSER</font></pre>
</blockquote>

<p>The generated parser class, named <font color="#008080"
size="2" face="Courier New"><em>MY_PARSER</em></font>, inherits
its lexical analyzer features (<font color="#008080" size="2"
face="Courier New"><em>read_token</em></font>, <font
color="#008080" size="2" face="Courier New"><em>last_token</em></font>
and <font color="#008080" size="2" face="Courier New"><em>last_value</em></font>)
from class <font color="#008080" size="2" face="Courier New"><em>MY_SCANNER</em></font>
which has probably been generated using <a
href="../gelex/gelex.html"><em>gelex</em></a>. The routine <font
color="#008080" size="2" face="Courier New"><em>report_error</em></font>,
inherited from <font color="#008080" size="2" face="Courier New"><em>YY_PARSER_SKELETON</em></font>,
has been redefined to keep track of the error messages reported
so far. Since the generic parameter of class <font
color="#008080" size="2" face="Courier New"><em>YY_PARSER_SKELETON
</em></font>is <font color="#008080" size="2" face="Courier New"><em>INTEGER</em></font>,
the semantic values of the tokens are integers. Finally, the
creation routine <font color="#008080" size="2"
face="Courier New"><em>make</em></font> initializes the lexical
analyzer and the parser and makes sure that the invariant is
preserved.</p>

<hr size="1">
<div align="left">

<address>
    <font size="2"><b>Copyright © 1997</b></font><font size="1"><b>,
    </b></font><font size="2"><strong>Eric Bezault</strong></font><strong>
    </strong><font size="2"><br>
    </font><a href="mailto:ericb@gobo.demon.co.uk"><font size="2">ericb@gobo.demon.co.uk</font></a><font
    size="2"> <br>
    </font><a href="http://www.gobo.demon.co.uk"><font size="2">http://www.gobo.demon.co.uk</font></a><font
    size="2"><br>
    <strong>Last Updated:</strong> 7 September 1997</font><br>
    <!--webbot bot="PurpleText"
    preview="
$Date$ 
$Revision$" --> 
</address>
</div>
</body>
</html>
